
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from '@/hooks/use-toast';

const SUPABASE_URL = "https://xyfwsmblaayznplurmfa.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh5ZndzbWJsYWF5em5wbHVybWZhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA4NjQ5MzAsImV4cCI6MjA1NjQ0MDkzMH0.iSMjuUMOEGVP-eU7p1xng_XlSc3pNg_DbViVwyD3Fc8";

// Track connection health
let lastSuccessfulConnection = Date.now();
let connectionHealthy = true;
let connectionAttempts = 0;

// Create the Supabase client with optimized configuration
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    storageKey: 'supabase-auth-token',
    storage: localStorage,
    flowType: 'implicit'
  },
  global: {
    // Optimized fetch function with balanced timeout values and better retry strategy
    fetch: (url, options) => {
      // Unique request ID for tracking
      const requestId = Math.random().toString(36).substring(2, 10);
      console.log(`Supabase request started [${requestId}]: ${options?.method || 'GET'} ${url.toString().split('?')[0]}`);
      
      // Enhanced retry logic with exponential backoff
      const maxRetries = url.toString().includes('/auth/') ? 3 : 2; // More retries for auth operations
      let retries = 0;
      
      const attemptFetch = async (): Promise<Response> => {
        try {
          // Further increased timeouts, especially for auth operations
          const isAuthOperation = url.toString().includes('/auth/');
          const timeout = isAuthOperation ? 25000 : 20000; // 25 sec for auth, 20 sec for others
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          const response = await fetch(url, {
            ...options,
            credentials: 'include',
            mode: 'cors',
            signal: controller.signal,
            headers: {
              ...options?.headers,
              'X-Request-ID': requestId,
              'Cache-Control': 'no-cache, no-store',
              'Pragma': 'no-cache',
            },
          });
          
          // Clear timeout if fetch completes
          clearTimeout(timeoutId);
          
          // Update connection health
          if (response.ok) {
            connectionHealthy = true;
            lastSuccessfulConnection = Date.now();
            connectionAttempts = 0;
            console.log(`Supabase request successful [${requestId}]`);
            return response;
          }
          
          // Enhanced error handling with more specific error messages
          if (response.status === 401) {
            console.warn(`Authentication error [${requestId}]: Token may have expired`);
            throw new Error(`Authentication error: Please sign in again`);
          } else if (response.status === 403) {
            console.warn(`Authorization error [${requestId}]: Insufficient permissions`);
            throw new Error(`Authorization error: You don't have permission to access this resource`);
          } else if (response.status === 429) {
            console.warn(`Rate limit error [${requestId}]: Too many requests`);
            throw new Error(`Rate limited: Too many requests. Please try again later.`);
          } else if (response.status >= 500) {
            console.warn(`Server error [${requestId}]: ${response.status}`);
            throw new Error(`Server error: The service is temporarily unavailable. Please try again later.`);
          } else {
            console.warn(`Request failed [${requestId}]: ${response.status}`);
            throw new Error(`Request failed: ${response.statusText || 'Unknown error'}`);
          }
        } catch (err: any) {
          // Update connection health on error
          connectionHealthy = false;
          connectionAttempts++;
          
          // Improved error handling with more specific messages
          if (err.name === 'AbortError') {
            console.error(`Request timeout [${requestId}] after ${err.message?.includes('25000') ? '25' : '20'} seconds`);
            throw new Error('The connection timed out. Server may be experiencing heavy load.');
          }
          
          if (!navigator.onLine) {
            console.error(`Offline error [${requestId}]`);
            throw new Error('You are currently offline. Please check your internet connection.');
          }
          
          // Enhanced retry logic with better categorization
          const isNetworkError = err.message?.includes('Failed to fetch') || 
                               err.name === 'TypeError' ||
                               err.name === 'AbortError';
                              
          const isAuthOperation = url.toString().includes('/auth/');
          const shouldRetry = isNetworkError || isAuthOperation || err.message?.includes('Server error');
          
          // Exponential backoff with jitter for more reliable retries
          if (retries < maxRetries && shouldRetry) {
            retries++;
            // Exponential backoff with jitter - more patience for auth operations
            const baseDelay = isAuthOperation ? 1500 : 1000;
            const delay = Math.min(baseDelay * Math.pow(2, retries) + Math.random() * 1000, 8000);
            console.log(`Retrying request [${requestId}] in ${Math.round(delay)}ms... (Attempt ${retries} of ${maxRetries})`);
            await new Promise(resolve => setTimeout(resolve, delay));
            return attemptFetch();
          }
          
          console.error(`Fetch error [${requestId}]:`, err);
          throw err;
        }
      };
      
      return attemptFetch();
    }
  }
});

// Auth state change handler with improved error capture
supabase.auth.onAuthStateChange(async (event, session) => {
  console.log(`Auth state changed: ${event}`);
  
  try {
    if (event === 'SIGNED_OUT') {
      console.log('User signed out');
    } else if (event === 'SIGNED_IN') {
      console.log('User signed in');
      lastSuccessfulConnection = Date.now(); // Update connection timestamp on successful auth
    } else if (event === 'TOKEN_REFRESHED') {
      console.log('Token refreshed');
      lastSuccessfulConnection = Date.now(); // Update connection timestamp on token refresh
    }
  } catch (error) {
    console.error('Error handling auth state change:', error);
  }
});

// More reliable connection check that handles network issues better
export const checkConnection = async (): Promise<boolean> => {
  if (!navigator.onLine) {
    return false;
  }
  
  try {
    // Use a simple HEAD request with increased reliability
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000); // Increased timeout to 10 seconds
    
    const response = await fetch(`${SUPABASE_URL}/rest/v1/`, {
      method: 'HEAD',
      headers: {
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Cache-Control': 'no-cache, no-store',
        'Pragma': 'no-cache',
      },
      signal: controller.signal,
    });
    
    clearTimeout(timeoutId);
    
    // Update connection health based on response
    if (response.ok) {
      connectionHealthy = true;
      lastSuccessfulConnection = Date.now();
      connectionAttempts = 0;
    }
    
    return response.ok;
  } catch (err) {
    console.error('Connection check failed:', err);
    connectionHealthy = false;
    connectionAttempts++;
    return false;
  }
};

// Enhanced connection refresh with better session handling
export const refreshSupabaseConnection = async (): Promise<boolean> => {
  if (!navigator.onLine) {
    return false;
  }
  
  try {
    console.log('Attempting to refresh Supabase connection...');
    
    // First check basic connectivity with increased timeout and retry
    let connected = false;
    let retries = 0;
    const maxRetries = 2;
    
    while (!connected && retries < maxRetries) {
      try {
        connected = await checkConnection();
        if (connected) break;
        
        retries++;
        console.log(`Basic connectivity check failed, retry ${retries}/${maxRetries}`);
        await new Promise(resolve => setTimeout(resolve, 1000 * retries));
      } catch (e) {
        console.error(`Error during connection check attempt ${retries}:`, e);
        retries++;
      }
    }
    
    if (!connected) {
      console.log('All basic connectivity checks failed');
      return false;
    }
    
    console.log('Basic connectivity check passed, attempting session refresh');
    
    // Then try to refresh session if present, with better error handling
    try {
      const { data, error } = await supabase.auth.getSession();
      
      if (error) {
        console.error('Error getting session during connection refresh:', error);
        return connected; // Still return true if basic connectivity is working
      }
      
      if (data.session) {
        console.log('Session found, refreshing...');
        
        try {
          const { error: refreshError } = await supabase.auth.refreshSession();
          
          if (refreshError) {
            console.error('Session refresh failed:', refreshError);
            // Don't fail the connection check just because refresh failed
          } else {
            console.log('Session refreshed successfully');
            lastSuccessfulConnection = Date.now();
            connectionHealthy = true;
            connectionAttempts = 0;
          }
        } catch (refreshErr) {
          console.error('Exception during session refresh:', refreshErr);
          // Don't fail the connection check just because refresh failed
        }
      } else {
        console.log('No session found to refresh');
      }
    } catch (e) {
      console.error('Session operation failed during connection check:', e);
      // Don't fail the connection check just because session operations failed
    }
    
    return true; // Return true if basic connectivity check passed
  } catch (err) {
    console.error('Failed to refresh Supabase connection:', err);
    return false;
  }
};

// Check authentication status with improved error handling
export const isAuthenticated = async (): Promise<boolean> => {
  if (!navigator.onLine) {
    try {
      // Check if we have a local session even when offline
      const { data: { session } } = await supabase.auth.getSession();
      if (session) {
        // We have a local session, but we're offline
        console.log("Found local session while offline");
        return true;
      }
      return false;
    } catch (err) {
      console.error('Error checking local authentication:', err);
      return false;
    }
  }
  
  try {
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error('Error checking authentication:', error);
      return false;
    }
    
    return !!session;
  } catch (err) {
    console.error('Exception checking authentication:', err);
    return false;
  }
};

// Enhanced connection health information with more detail
export const getConnectionHealth = () => {
  if (!navigator.onLine) {
    return {
      status: 'offline',
      lastSuccess: lastSuccessfulConnection,
      timeSinceSuccess: Date.now() - lastSuccessfulConnection,
      attempts: connectionAttempts,
      detail: 'Device is offline'
    };
  }
  
  const timeSinceLastSuccess = Date.now() - lastSuccessfulConnection;
  
  if (!connectionHealthy || timeSinceLastSuccess > 5 * 60 * 1000) { // 5 minutes
    return {
      status: 'degraded',
      lastSuccess: lastSuccessfulConnection,
      timeSinceSuccess: timeSinceLastSuccess,
      attempts: connectionAttempts,
      detail: connectionAttempts > 3 ? 'Multiple connection failures' : 'Connection unstable'
    };
  }
  
  return {
    status: 'healthy',
    lastSuccess: lastSuccessfulConnection,
    timeSinceSuccess: timeSinceLastSuccess,
    attempts: connectionAttempts,
    detail: 'Connection stable'
  };
};
