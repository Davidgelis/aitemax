
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from '@/hooks/use-toast';

const SUPABASE_URL = "https://xyfwsmblaayznplurmfa.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh5ZndzbWJsYWF5em5wbHVybWZhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA4NjQ5MzAsImV4cCI6MjA1NjQ0MDkzMH0.iSMjuUMOEGVP-eU7p1xng_XlSc3pNg_DbViVwyD3Fc8";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Track connection health for smart reconnection
let lastSuccessfulConnection = Date.now();
let connectionHealthy = true;
let connectionAttempts = 0;

// Create the Supabase client with auto-refresh for JWT tokens
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    storageKey: 'supabase-auth-token',
    storage: localStorage
  },
  global: {
    // Enhanced fetch with connection timeout and better error handling
    fetch: (url, options) => {
      // Generate a unique request ID for tracking
      const requestId = Math.random().toString(36).substring(2, 10);
      console.log(`Supabase request started [${requestId}]: ${options?.method || 'GET'} ${url.toString().split('?')[0]}`);
      
      // Set up retry with exponential backoff
      const maxRetries = 3;
      let retries = 0;
      
      const attemptFetch = async (): Promise<Response> => {
        try {
          // Add timeout to fetch requests using AbortController
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
          
          // Add CORS headers to improve cross-origin request handling
          const response = await fetch(url, {
            ...options,
            credentials: 'include', // Include cookies for cross-origin requests
            mode: 'cors', // Enable CORS explicitly
            signal: controller.signal,
            headers: {
              ...options?.headers,
              'X-Request-ID': requestId,
              'Cache-Control': 'no-cache, no-store',
            },
          });
          
          // Clear timeout if fetch completes
          clearTimeout(timeoutId);
          
          // Update connection health metrics on success
          if (response.ok) {
            connectionHealthy = true;
            lastSuccessfulConnection = Date.now();
            connectionAttempts = 0;
            console.log(`Supabase request successful [${requestId}]`);
            return response;
          }
          
          // Auth specific error handling - critical for login flows
          if (response.status === 401) {
            console.log(`Token expired, attempting to refresh session [${requestId}]`);
            
            try {
              // Try to reauthenticate but avoid recursive call to refreshSession
              const authResponse = await fetch(`${SUPABASE_URL}/auth/v1/token?grant_type=refresh_token`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'apikey': SUPABASE_PUBLISHABLE_KEY,
                },
                body: JSON.stringify({
                  refresh_token: JSON.parse(localStorage.getItem('supabase-auth-token') || '{}')?.refresh_token,
                }),
              });
              
              if (authResponse.ok) {
                // Successfully refreshed token
                console.log(`Token refreshed manually [${requestId}]`);
                
                // Retry the original request with the new token
                return fetch(url, {
                  ...options,
                  credentials: 'include',
                  mode: 'cors',
                  headers: {
                    ...options?.headers
                  }
                });
              } else {
                console.error(`Session refresh failed [${requestId}]:`, await authResponse.text());
                throw new Error(`Authentication refresh failed`);
              }
            } catch (refreshErr) {
              console.error(`Session refresh failed [${requestId}]:`, refreshErr);
              throw new Error(`Authentication refresh failed: ${refreshErr}`);
            }
          }
          
          // More precise error handling based on HTTP status codes
          if (response.status >= 500) {
            throw new Error(`Server error (${response.status}): The server is currently unavailable`);
          } else if (response.status === 429) {
            throw new Error(`Rate limited: Too many requests. Please try again later.`);
          } else {
            throw new Error(`Fetch failed with status ${response.status}: ${response.statusText}`);
          }
          
        } catch (err: any) {
          // Record connection issue
          connectionHealthy = false;
          connectionAttempts++;
          
          // Handle abort/timeout specifically
          if (err.name === 'AbortError') {
            console.error(`Request timeout [${requestId}] - server took too long to respond`);
            throw new Error('Connection timed out. The server is taking too long to respond.');
          }
          
          // Handle CORS errors more specifically
          if (err.message?.includes('CORS')) {
            console.error(`CORS error detected [${requestId}]`);
            throw new Error('Cross-origin request blocked. This is likely a network configuration issue.');
          }
          
          // Check if we should retry
          if (retries < maxRetries) {
            retries++;
            const delay = Math.pow(2, retries) * 500; // Exponential backoff
            console.log(`Retrying request [${requestId}] (${retries}/${maxRetries}) after ${delay}ms...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            return attemptFetch();
          }
          
          // Check if it's likely a network issue
          if (err.message?.includes('Failed to fetch') || !navigator.onLine) {
            console.error(`Network connection issue detected [${requestId}]`);
            throw new Error('Network connection issue. Please check your internet connection.');
          }
          
          // Log detailed error info after all retries failed
          console.error(`Fetch error in Supabase client [${requestId}]:`, err);
          
          // Show user-friendly toast notification after all retries have failed
          toast({
            title: "Connection Error",
            description: "We're having trouble connecting to our services. Please check your internet connection or try again later.",
            variant: "destructive",
          });
          
          // Re-throw to allow Supabase's built-in retry logic to work
          throw err;
        }
      };
      
      // Start the initial fetch attempt
      return attemptFetch();
    }
  }
});

// ðŸ”„ always keep an anonymous / refreshed JWT with enhanced error handling
supabase.auth.onAuthStateChange(async (event, session) => {
  console.log(`Auth state changed: ${event}`);
  
  if (!session) {
    console.log('No session found, reauthenticating...');
    try {
      const { data, error } = await supabase.auth.reauthenticate();
      if (error) {
        console.error('Reauthentication failed:', error);
      } else {
        console.log('Reauthentication successful');
      }
    } catch (err) {
      console.error('Unexpected error during reauthentication:', err);
    }
  } else {
    // Log detailed session information for debugging
    const expiresAt = session.expires_at ? new Date(session.expires_at * 1000) : 'unknown';
    console.log(`Session updated, expires: ${expiresAt}`);
    
    // Check if session is about to expire and proactively refresh
    if (session.expires_at) {
      const expiryTime = new Date(session.expires_at * 1000);
      const now = new Date();
      const timeUntilExpiry = expiryTime.getTime() - now.getTime();
      
      // If session expires in less than 5 minutes, refresh it proactively
      if (timeUntilExpiry < 5 * 60 * 1000) {
        console.log('Session expires soon, refreshing proactively');
        try {
          await supabase.auth.refreshSession();
          console.log('Session refreshed proactively');
        } catch (err) {
          console.error('Failed to refresh session proactively:', err);
        }
      }
    }
  }
});

// Improved connection check with better diagnostics and more reliable testing endpoint
const checkConnection = async () => {
  try {
    console.log('Checking Supabase connection...');
    
    // First check basic internet connectivity
    if (!navigator.onLine) {
      console.log('Device is offline');
      return false;
    }
    
    // Use a more reliable endpoint for DNS check
    try {
      const startTime = Date.now();
      const dnsCheckResponse = await fetch('https://www.google.com/favicon.ico', { 
        method: 'HEAD',
        cache: 'no-store',
        mode: 'no-cors'
      });
      const responseTime = Date.now() - startTime;
      console.log(`Internet connectivity confirmed (${responseTime}ms latency)`);
    } catch (err) {
      console.warn('Basic internet connectivity check failed:', err);
      // Continue anyway, the problem might be specific to google.com
    }
    
    // Test health endpoint first which is faster and more reliable
    try {
      const healthCheckStart = Date.now();
      const healthResponse = await fetch(`${SUPABASE_URL}/rest/v1/`, {
        headers: {
          'apikey': SUPABASE_PUBLISHABLE_KEY,
        },
      });
      
      const healthCheckTime = Date.now() - healthCheckStart;
      
      if (!healthResponse.ok) {
        console.error(`Supabase health check failed: ${healthResponse.status} ${healthResponse.statusText}`);
        toast({
          title: "Service Unavailable",
          description: "Our services appear to be temporarily unavailable. Please try again later.",
          variant: "destructive",
        });
        return false;
      }
      
      console.log(`Supabase health check successful (${healthCheckTime}ms)`);
    } catch (err) {
      console.error('Supabase health check failed:', err);
      toast({
        title: "Connection Error",
        description: "Unable to reach our services. Please check your connection and try again.",
        variant: "destructive", 
      });
      return false;
    }
    
    // Then check auth status - this is important for login flows
    const { data: authData } = await supabase.auth.getSession();
    if (!authData.session) {
      console.log('No active session found during connection check');
    } else {
      console.log('Active session found, user:', authData.session.user.id);
    }
    
    // Then check database connectivity with a simple query
    const startTime = Date.now();
    const { error } = await supabase.from('supported_languages').select('id').limit(1);
    const responseTime = Date.now() - startTime;
    
    if (error) {
      console.error('Supabase connection check failed:', error);
      
      if (error.message?.includes('Failed to fetch') || error.code === 'NETWORK_ERROR') {
        toast({
          title: "Connection Error",
          description: "Unable to connect to our servers. Please verify your internet connection and try again.",
          variant: "destructive",
        });
      } else if (error.code === 'PGRST301') {
        toast({
          title: "Authentication Error",
          description: "Your session may have expired. Please try signing in again.",
          variant: "destructive",
        });
      } else {
        toast({
          title: "Service Error",
          description: "We're having trouble connecting to our services. Please try again later.",
          variant: "destructive",
        });
      }
      
      return false;
    } else {
      console.log(`Supabase connection established successfully (${responseTime}ms response time)`);
      lastSuccessfulConnection = Date.now();
      connectionHealthy = true;
      return true;
    }
  } catch (err) {
    console.error('Supabase connection check exception:', err);
    toast({
      title: "Connection Error",
      description: "Unexpected error connecting to our services. Please refresh the page and try again.",
      variant: "destructive",
    });
    return false;
  }
};

// Run connection check when the app starts
window.addEventListener('load', () => {
  setTimeout(checkConnection, 1000); // Slight delay to avoid competing with other initialization processes
});

// Export an enhanced function to manually refresh the connection
export const refreshSupabaseConnection = async (): Promise<boolean> => {
  try {
    console.log('Manually refreshing Supabase connection...');
    
    // Check if device is online first
    if (!navigator.onLine) {
      toast({
        title: "You're Offline",
        description: "Please check your internet connection and try again.",
        variant: "destructive",
      });
      return false;
    }
    
    // Clear any local storage caches that might be corrupted
    const preservedItems = {};
    
    // First attempt to get the session so we can preserve it if valid
    const { data: sessionData } = await supabase.auth.getSession();
    if (sessionData?.session) {
      console.log('Found existing session, attempting to preserve');
      preservedItems['session'] = sessionData.session;
    }
    
    // Try to refresh the token
    if (sessionData?.session) {
      console.log('Session is active, refreshing token...');
      const { data: refreshData, error: refreshError } = await supabase.auth.refreshSession();
      
      if (refreshError) {
        console.error('Failed to refresh session:', refreshError);
        // Try reauthenticating as fallback
        await supabase.auth.reauthenticate();
      } else {
        console.log('Session refreshed successfully');
      }
    } else {
      console.log('No active session, reauthenticating...');
      await supabase.auth.reauthenticate();
    }
    
    // Test the connection after refresh
    const connectionSuccess = await checkConnection();
    
    // Show appropriate toast based on result
    if (connectionSuccess) {
      toast({
        title: "Connection Restored",
        description: "Your connection has been successfully refreshed.",
        variant: "default",
      });
    }
    
    return connectionSuccess;
  } catch (err) {
    console.error('Failed to refresh Supabase connection:', err);
    
    toast({
      title: "Connection Error",
      description: "Unable to restore connection. Please try refreshing the page.",
      variant: "destructive",
    });
    
    return false;
  }
};

// Export a function to check if the user is authenticated
export const isAuthenticated = async (): Promise<boolean> => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    return !!session;
  } catch (err) {
    console.error('Error checking authentication status:', err);
    return false;
  }
};

// Monitor and report connection quality
export const getConnectionHealth = () => {
  if (!connectionHealthy) {
    return {
      status: 'degraded',
      lastSuccess: lastSuccessfulConnection,
      timeSinceSuccess: Date.now() - lastSuccessfulConnection,
      attempts: connectionAttempts
    };
  }
  return {
    status: 'healthy',
    lastSuccess: lastSuccessfulConnection,
    timeSinceSuccess: Date.now() - lastSuccessfulConnection,
    attempts: connectionAttempts
  };
};
