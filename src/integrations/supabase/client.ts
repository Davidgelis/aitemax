
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { toast } from '@/hooks/use-toast';

const SUPABASE_URL = "https://xyfwsmblaayznplurmfa.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inh5ZndzbWJsYWF5em5wbHVybWZhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA4NjQ5MzAsImV4cCI6MjA1NjQ0MDkzMH0.iSMjuUMOEGVP-eU7p1xng_XlSc3pNg_DbViVwyD3Fc8";

// Track connection health
let lastSuccessfulConnection = Date.now();
let connectionHealthy = true;
let connectionAttempts = 0;

// Create the Supabase client with optimized configuration
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    storageKey: 'supabase-auth-token',
    storage: localStorage,
    flowType: 'implicit'
  },
  global: {
    // Optimized fetch function with balanced timeout values
    fetch: (url, options) => {
      // Unique request ID for tracking
      const requestId = Math.random().toString(36).substring(2, 10);
      console.log(`Supabase request started [${requestId}]: ${options?.method || 'GET'} ${url.toString().split('?')[0]}`);
      
      // Simplified retry logic
      const maxRetries = 2; // Increased from 1 to 2 for auth operations
      let retries = 0;
      
      const attemptFetch = async (): Promise<Response> => {
        try {
          // Adjusted timeouts for better reliability, especially for auth
          const isAuthOperation = url.toString().includes('/auth/');
          const timeout = isAuthOperation ? 20000 : 15000; // Increased timeouts (20 sec for auth, 15 sec for others)
          
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);
          
          const response = await fetch(url, {
            ...options,
            credentials: 'include',
            mode: 'cors',
            signal: controller.signal,
            headers: {
              ...options?.headers,
              'X-Request-ID': requestId,
              'Cache-Control': 'no-cache, no-store',
              'Pragma': 'no-cache',
            },
          });
          
          // Clear timeout if fetch completes
          clearTimeout(timeoutId);
          
          // Update connection health
          if (response.ok) {
            connectionHealthy = true;
            lastSuccessfulConnection = Date.now();
            connectionAttempts = 0;
            console.log(`Supabase request successful [${requestId}]`);
            return response;
          }
          
          // Better error handling for common status codes
          if (response.status === 401) {
            console.log(`Authentication error [${requestId}]: Token may have expired`);
            throw new Error(`Authentication error: Please sign in again`);
          } else if (response.status === 403) {
            console.log(`Authorization error [${requestId}]: Insufficient permissions`);
            throw new Error(`Authorization error: You don't have permission to access this resource`);
          } else if (response.status === 429) {
            console.log(`Rate limit error [${requestId}]: Too many requests`);
            throw new Error(`Rate limited: Too many requests. Please try again later.`);
          } else if (response.status >= 500) {
            console.log(`Server error [${requestId}]: ${response.status}`);
            throw new Error(`Server error: The service is temporarily unavailable. Please try again later.`);
          } else {
            console.log(`Request failed [${requestId}]: ${response.status}`);
            throw new Error(`Request failed: ${response.statusText || 'Unknown error'}`);
          }
        } catch (err: any) {
          // Update connection health on error
          connectionHealthy = false;
          connectionAttempts++;
          
          // Simplified error handling with better messages
          if (err.name === 'AbortError') {
            console.error(`Request timeout [${requestId}] after ${err.message?.includes('20000') ? '20' : '15'} seconds`);
            throw new Error('The connection timed out. Please try again.');
          }
          
          if (!navigator.onLine) {
            console.error(`Offline error [${requestId}]`);
            throw new Error('You are currently offline. Please check your internet connection.');
          }
          
          // Improved retry logic, especially for network and auth errors
          const isNetworkError = err.message?.includes('Failed to fetch') || 
                               err.name === 'TypeError' ||
                               err.name === 'AbortError';
                              
          const isAuthOperation = url.toString().includes('/auth/');
          
          // More retries for auth operations
          if (retries < maxRetries && (isNetworkError || isAuthOperation)) {
            retries++;
            // Exponential backoff with jitter for more reliable retries
            const delay = Math.min(1000 * Math.pow(2, retries) + Math.random() * 1000, 5000);
            console.log(`Retrying request [${requestId}] in ${Math.round(delay)}ms... (Attempt ${retries} of ${maxRetries})`);
            await new Promise(resolve => setTimeout(resolve, delay));
            return attemptFetch();
          }
          
          console.error(`Fetch error [${requestId}]:`, err);
          throw err;
        }
      };
      
      return attemptFetch();
    }
  }
});

// Simpler auth state change handler
supabase.auth.onAuthStateChange(async (event, session) => {
  console.log(`Auth state changed: ${event}`);
  
  if (event === 'SIGNED_OUT') {
    console.log('User signed out');
  } else if (event === 'SIGNED_IN') {
    console.log('User signed in');
  } else if (event === 'TOKEN_REFRESHED') {
    console.log('Token refreshed');
  }
});

// Improved connection check for UI indications
export const checkConnection = async (): Promise<boolean> => {
  if (!navigator.onLine) {
    return false;
  }
  
  try {
    // Use a simple HEAD request to check connectivity with increased timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 7000); // Increased timeout to 7 seconds
    
    const response = await fetch(`${SUPABASE_URL}/rest/v1/`, {
      method: 'HEAD',
      headers: {
        'apikey': SUPABASE_PUBLISHABLE_KEY,
      },
      signal: controller.signal,
    });
    
    clearTimeout(timeoutId);
    return response.ok;
  } catch (err) {
    console.error('Connection check failed:', err);
    return false;
  }
};

// Enhanced function to refresh connection
export const refreshSupabaseConnection = async (): Promise<boolean> => {
  if (!navigator.onLine) {
    return false;
  }
  
  try {
    console.log('Attempting to refresh Supabase connection...');
    
    // First check basic connectivity with increased timeout
    const connected = await checkConnection();
    if (!connected) {
      console.log('Basic connectivity check failed');
      return false;
    }
    
    console.log('Basic connectivity check passed, attempting session refresh');
    
    // Then try to refresh session if present
    try {
      const { data } = await supabase.auth.getSession();
      if (data.session) {
        console.log('Session found, refreshing...');
        await supabase.auth.refreshSession();
        console.log('Session refreshed successfully');
      } else {
        console.log('No session found to refresh');
      }
    } catch (e) {
      console.error('Session refresh failed during connection check:', e);
      // Non-fatal, continue
    }
    
    return true;
  } catch (err) {
    console.error('Failed to refresh Supabase connection:', err);
    return false;
  }
};

// Check authentication status
export const isAuthenticated = async (): Promise<boolean> => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    return !!session;
  } catch (err) {
    console.error('Error checking authentication:', err);
    return false;
  }
};

// Connection health information
export const getConnectionHealth = () => {
  if (!navigator.onLine) {
    return {
      status: 'offline',
      lastSuccess: lastSuccessfulConnection,
      timeSinceSuccess: Date.now() - lastSuccessfulConnection,
      attempts: connectionAttempts
    };
  }
  
  if (!connectionHealthy) {
    return {
      status: 'degraded',
      lastSuccess: lastSuccessfulConnection,
      timeSinceSuccess: Date.now() - lastSuccessfulConnection,
      attempts: connectionAttempts
    };
  }
  
  return {
    status: 'healthy',
    lastSuccess: lastSuccessfulConnection,
    timeSinceSuccess: Date.now() - lastSuccessfulConnection,
    attempts: connectionAttempts
  };
};
